{"ast":null,"code":"import _classCallCheck from \"/Users/j.wright/SF-main-repo/alchemist-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/j.wright/SF-main-repo/alchemist-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport getShadowHost from '../get/shadow-host';\nimport mergeInDomOrder from '../util/merge-dom-order';\nimport tabindexValue from '../util/tabindex-value';\n\nvar Shadows =\n/*#__PURE__*/\nfunction () {\n  function Shadows(context, sortElements) {\n    _classCallCheck(this, Shadows);\n\n    // document context we're working with\n    this.context = context; // callback that sorts an array of elements\n\n    this.sortElements = sortElements; // reference to create unique IDs for each ShadowHost\n\n    this.hostCounter = 1; // reference map for child-ShadowHosts of a ShadowHost\n\n    this.inHost = {}; // reference map for child-ShadowHost of the document\n\n    this.inDocument = []; // reference map for ShadowHosts\n\n    this.hosts = {}; // reference map for tabbable elements of a ShadowHost\n\n    this.elements = {};\n  } // remember which hosts we have to sort within later\n\n\n  _createClass(Shadows, [{\n    key: \"_registerHost\",\n    value: function _registerHost(host) {\n      if (host._sortingId) {\n        return;\n      } // make the ShadowHost identifiable (see cleanup() for undo)\n\n\n      host._sortingId = 'shadow-' + this.hostCounter++;\n      this.hosts[host._sortingId] = host; // hosts may contain other hosts\n\n      var parentHost = getShadowHost({\n        context: host\n      });\n\n      if (parentHost) {\n        this._registerHost(parentHost);\n\n        this._registerHostParent(host, parentHost);\n      } else {\n        this.inDocument.push(host);\n      }\n    } // remember which host is the child of which other host\n\n  }, {\n    key: \"_registerHostParent\",\n    value: function _registerHostParent(host, parent) {\n      if (!this.inHost[parent._sortingId]) {\n        this.inHost[parent._sortingId] = [];\n      }\n\n      this.inHost[parent._sortingId].push(host);\n    } // remember which elements a host contains\n\n  }, {\n    key: \"_registerElement\",\n    value: function _registerElement(element, host) {\n      if (!this.elements[host._sortingId]) {\n        this.elements[host._sortingId] = [];\n      }\n\n      this.elements[host._sortingId].push(element);\n    } // remove shadowed elements from the sequence and register\n    // the ShadowHosts they belong to so we know what to sort\n    // later on\n\n  }, {\n    key: \"extractElements\",\n    value: function extractElements(elements) {\n      return elements.filter(function (element) {\n        var host = getShadowHost({\n          context: element\n        });\n\n        if (!host) {\n          return true;\n        }\n\n        this._registerHost(host);\n\n        this._registerElement(element, host);\n\n        return false;\n      }, this);\n    } // inject hosts into the sequence, sort everything,\n    // and recoursively replace hosts by its descendants\n\n  }, {\n    key: \"sort\",\n    value: function sort(elements) {\n      var _elements = this._injectHosts(elements);\n\n      _elements = this._replaceHosts(_elements);\n\n      this._cleanup();\n\n      return _elements;\n    } // merge ShadowHosts into the element lists of other ShadowHosts\n    // or the document, then sort the individual lists\n\n  }, {\n    key: \"_injectHosts\",\n    value: function _injectHosts(elements) {\n      Object.keys(this.hosts).forEach(function (_sortingId) {\n        var _list = this.elements[_sortingId];\n        var _elements = this.inHost[_sortingId];\n        var _context = this.hosts[_sortingId].shadowRoot;\n        this.elements[_sortingId] = this._merge(_list, _elements, _context);\n      }, this);\n      return this._merge(elements, this.inDocument, this.context);\n    }\n  }, {\n    key: \"_merge\",\n    value: function _merge(list, elements, context) {\n      var merged = mergeInDomOrder({\n        list: list,\n        elements: elements\n      });\n      return this.sortElements(merged, context);\n    }\n  }, {\n    key: \"_replaceHosts\",\n    value: function _replaceHosts(elements) {\n      return mergeInDomOrder({\n        list: elements,\n        elements: this.inDocument,\n        resolveElement: this._resolveHostElement.bind(this)\n      });\n    }\n  }, {\n    key: \"_resolveHostElement\",\n    value: function _resolveHostElement(host) {\n      var merged = mergeInDomOrder({\n        list: this.elements[host._sortingId],\n        elements: this.inHost[host._sortingId],\n        resolveElement: this._resolveHostElement.bind(this)\n      });\n\n      var _tabindex = tabindexValue(host);\n\n      if (_tabindex !== null && _tabindex > -1) {\n        return [host].concat(merged);\n      }\n\n      return merged;\n    }\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      // remove those identifers we put on the ShadowHost to avoid using Map()\n      Object.keys(this.hosts).forEach(function (key) {\n        delete this.hosts[key]._sortingId;\n      }, this);\n    }\n  }]);\n\n  return Shadows;\n}();\n\nexport default function (elements, context, sortElements) {\n  var shadows = new Shadows(context, sortElements);\n\n  var _elements = shadows.extractElements(elements);\n\n  if (_elements.length === elements.length) {\n    // no shadowed content found, no need to continue\n    return sortElements(elements);\n  }\n\n  return shadows.sort(_elements);\n}","map":null,"metadata":{},"sourceType":"module"}