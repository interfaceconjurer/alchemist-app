{"ast":null,"code":"// determine if an element can be focused by keyboard (i.e. is part of the document's sequential focus navigation order)\nimport isVisible from './visible';\nimport contextToElement from '../util/context-to-element';\nimport elementMatches from '../util/element-matches';\nimport tabindexValue from '../util/tabindex-value';\nimport focusRelevant from './focus-relevant';\nimport getFrameElement from '../util/get-frame-element';\nimport platform from '../util/platform';\nimport { getImageOfArea } from '../util/image-map';\nimport { hasCssOverflowScroll, hasCssDisplayFlex, isScrollableContainer, isUserModifyWritable } from './is.util';\nimport _supports from '../supports/supports';\nvar supports; // Internet Explorer 11 considers fieldset, table, td focusable, but not tabbable\n// Internet Explorer 11 considers body to have [tabindex=0], but does not allow tabbing to it\n\nvar focusableElementsPattern = /^(fieldset|table|td|body)$/;\n\nfunction isTabbableRules() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      context = _ref.context,\n      _ref$except = _ref.except,\n      except = _ref$except === void 0 ? {\n    flexbox: false,\n    scrollable: false,\n    shadow: false,\n    visible: false,\n    onlyTabbable: false\n  } : _ref$except;\n\n  if (!supports) {\n    supports = _supports();\n  }\n\n  var element = contextToElement({\n    label: 'is/tabbable',\n    resolveDocument: true,\n    context: context\n  });\n\n  if (platform.is.BLINK && platform.is.ANDROID && platform.majorVersion > 42) {\n    // External keyboard support worked fine in CHrome 42, but stopped working in Chrome 45.\n    // The on-screen keyboard does not provide a way to focus the next input element (like iOS does).\n    // That leaves us with no option to advance focus by keyboard, ergo nothing is tabbable (keyboard focusable).\n    return false;\n  }\n\n  var frameElement = getFrameElement(element);\n\n  if (frameElement) {\n    if (platform.is.WEBKIT && platform.is.IOS) {\n      // iOS only does not consider anything from another browsing context keyboard focusable\n      return false;\n    } // iframe[tabindex=\"-1\"] and object[tabindex=\"-1\"] inherit the\n    // tabbable demotion onto elements of their browsing contexts\n\n\n    if (tabindexValue(frameElement) < 0) {\n      return false;\n    }\n\n    if (!except.visible && (platform.is.BLINK || platform.is.WEBKIT) && !isVisible(frameElement)) {\n      // Blink and WebKit consider elements in hidden browsing contexts focusable, but not tabbable\n      return false;\n    } // Webkit and Blink don't consider anything in <object> tabbable\n    // Blink fixed that fixed in Chrome 54, Opera 41\n\n\n    var frameNodeName = frameElement.nodeName.toLowerCase();\n\n    if (frameNodeName === 'object') {\n      var isFixedBlink = platform.name === 'Chrome' && platform.majorVersion >= 54 || platform.name === 'Opera' && platform.majorVersion >= 41;\n\n      if (platform.is.WEBKIT || platform.is.BLINK && !isFixedBlink) {\n        return false;\n      }\n    }\n  }\n\n  var nodeName = element.nodeName.toLowerCase();\n\n  var _tabindex = tabindexValue(element);\n\n  var tabindex = _tabindex === null ? null : _tabindex >= 0;\n\n  if (platform.is.EDGE && platform.majorVersion >= 14 && frameElement && element.ownerSVGElement && _tabindex < 0) {\n    // Edge 14+ considers <a xlink:href=\"â€¦\" tabindex=\"-1\"> keyboard focusable\n    // if the element is in a nested browsing context\n    return true;\n  }\n\n  var hasTabbableTabindexOrNone = tabindex !== false;\n  var hasTabbableTabindex = _tabindex !== null && _tabindex >= 0; // NOTE: Firefox 31 considers [contenteditable] to have [tabindex=-1], but allows tabbing to it\n  // fixed in Firefox 40 the latest - https://bugzilla.mozilla.org/show_bug.cgi?id=1185657\n\n  if (element.hasAttribute('contenteditable')) {\n    // tabbing can still be disabled by explicitly providing [tabindex=\"-1\"]\n    return hasTabbableTabindexOrNone;\n  }\n\n  if (focusableElementsPattern.test(nodeName) && tabindex !== true) {\n    return false;\n  }\n\n  if (platform.is.WEBKIT && platform.is.IOS) {\n    // iOS only considers a hand full of elements tabbable (keyboard focusable)\n    // this holds true even with external keyboards\n    var potentiallyTabbable = nodeName === 'input' && element.type === 'text' || element.type === 'password' || nodeName === 'select' || nodeName === 'textarea' || element.hasAttribute('contenteditable');\n\n    if (!potentiallyTabbable) {\n      var style = window.getComputedStyle(element, null);\n      potentiallyTabbable = isUserModifyWritable(style);\n    }\n\n    if (!potentiallyTabbable) {\n      return false;\n    }\n  }\n\n  if (nodeName === 'use' && _tabindex !== null) {\n    if (platform.is.BLINK || platform.is.WEBKIT && platform.majorVersion === 9) {\n      // In Chrome and Safari 9 the <use> element is keyboard focusable even for tabindex=\"-1\"\n      return true;\n    }\n  }\n\n  if (elementMatches(element, 'svg a') && element.hasAttribute('xlink:href')) {\n    if (hasTabbableTabindexOrNone) {\n      // in Trident and Gecko SVGElement does not handle the tabIndex property properly\n      return true;\n    }\n\n    if (element.focus && !supports.focusSvgNegativeTabindexAttribute) {\n      // Firefox 51 and 52 treat any natively tabbable SVG element with\n      // tabindex=\"-1\" as tabbable and everything else as inert\n      // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340\n      return true;\n    }\n  }\n\n  if (nodeName === 'svg' && supports.focusSvgInIframe && hasTabbableTabindexOrNone) {\n    return true;\n  }\n\n  if (platform.is.TRIDENT || platform.is.EDGE) {\n    if (nodeName === 'svg') {\n      if (supports.focusSvg) {\n        // older Internet Explorers consider <svg> keyboard focusable\n        // unless they have focsable=\"false\", but then they wouldn't\n        // be focusable and thus not even reach this filter\n        return true;\n      } // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value\n\n\n      return element.hasAttribute('focusable') || hasTabbableTabindex;\n    }\n\n    if (element.ownerSVGElement) {\n      if (supports.focusSvgTabindexAttribute && hasTabbableTabindex) {\n        return true;\n      } // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value\n\n\n      return element.hasAttribute('focusable');\n    }\n  }\n\n  if (element.tabIndex === undefined) {\n    return Boolean(except.onlyTabbable);\n  }\n\n  if (nodeName === 'audio') {\n    if (!element.hasAttribute('controls')) {\n      // In Internet Explorer the <audio> element is focusable, but not tabbable, and tabIndex property is wrong\n      return false;\n    } else if (platform.is.BLINK) {\n      // In Chrome <audio controls tabindex=\"-1\"> remains keyboard focusable\n      return true;\n    }\n  }\n\n  if (nodeName === 'video') {\n    if (!element.hasAttribute('controls')) {\n      if (platform.is.TRIDENT || platform.is.EDGE) {\n        // In Internet Explorer and Edge the <video> element is focusable, but not tabbable, and tabIndex property is wrong\n        return false;\n      }\n    } else if (platform.is.BLINK || platform.is.GECKO) {\n      // In Chrome and Firefox <video controls tabindex=\"-1\"> remains keyboard focusable\n      return true;\n    }\n  }\n\n  if (nodeName === 'object') {\n    if (platform.is.BLINK || platform.is.WEBKIT) {\n      // In all Blink and WebKit based browsers <embed> and <object> are never keyboard focusable, even with tabindex=\"0\" set\n      return false;\n    }\n  }\n\n  if (nodeName === 'iframe') {\n    // In Internet Explorer all iframes are only focusable\n    // In WebKit, Blink and Gecko iframes may be tabbable depending on content.\n    // Since we can't reliably investigate iframe documents because of the\n    // SameOriginPolicy, we're declaring everything only focusable.\n    return false;\n  }\n\n  if (!except.scrollable && platform.is.GECKO) {\n    // Firefox considers scrollable containers keyboard focusable,\n    // even though their tabIndex property is -1\n    var _style = window.getComputedStyle(element, null);\n\n    if (hasCssOverflowScroll(_style)) {\n      return hasTabbableTabindexOrNone;\n    }\n  }\n\n  if (platform.is.TRIDENT || platform.is.EDGE) {\n    // IE and Edge degrade <area> to script focusable, if the image\n    // using the <map> has been given tabindex=\"-1\"\n    if (nodeName === 'area') {\n      var img = getImageOfArea(element);\n\n      if (img && tabindexValue(img) < 0) {\n        return false;\n      }\n    }\n\n    var _style2 = window.getComputedStyle(element, null);\n\n    if (isUserModifyWritable(_style2)) {\n      // prevent being swallowed by the overzealous isScrollableContainer() below\n      return element.tabIndex >= 0;\n    }\n\n    if (!except.flexbox && hasCssDisplayFlex(_style2)) {\n      if (_tabindex !== null) {\n        return hasTabbableTabindex;\n      }\n\n      return isFocusRelevantWithoutFlexbox(element) && isTabbableWithoutFlexbox(element);\n    } // IE considers scrollable containers script focusable only,\n    // even though their tabIndex property is 0\n\n\n    if (isScrollableContainer(element, nodeName)) {\n      return false;\n    }\n\n    var parent = element.parentElement;\n\n    if (parent) {\n      var parentNodeName = parent.nodeName.toLowerCase();\n      var parentStyle = window.getComputedStyle(parent, null); // IE considers scrollable bodies script focusable only,\n\n      if (isScrollableContainer(parent, nodeName, parentNodeName, parentStyle)) {\n        return false;\n      } // Children of focusable elements with display:flex are focusable in IE10-11,\n      // even though their tabIndex property suggests otherwise\n\n\n      if (hasCssDisplayFlex(parentStyle)) {\n        // value of tabindex takes precedence\n        return hasTabbableTabindex;\n      }\n    }\n  } // https://www.w3.org/WAI/PF/aria-practices/#focus_tabindex\n\n\n  return element.tabIndex >= 0;\n} // bind exceptions to an iterator callback\n\n\nisTabbableRules.except = function () {\n  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var isTabbable = function isTabbable(context) {\n    return isTabbableRules({\n      context: context,\n      except: except\n    });\n  };\n\n  isTabbable.rules = isTabbableRules;\n  return isTabbable;\n};\n\nvar isFocusRelevantWithoutFlexbox = focusRelevant.rules.except({\n  flexbox: true\n});\nvar isTabbableWithoutFlexbox = isTabbableRules.except({\n  flexbox: true\n}); // provide isTabbable(context) as default iterator callback\n\nvar isTabbable = isTabbableRules.except({});\nexport default isTabbable;","map":null,"metadata":{},"sourceType":"module"}