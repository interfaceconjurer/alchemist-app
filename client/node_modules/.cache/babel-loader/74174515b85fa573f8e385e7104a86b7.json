{"ast":null,"code":"import _classCallCheck from \"/Users/j.wright/SF-main-repo/alchemist-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/j.wright/SF-main-repo/alchemist-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport nodeArray from '../util/node-array';\nimport queryShadowHosts from '../query/shadow-hosts';\nimport contextToElement from '../util/context-to-element';\nvar shadowObserverConfig = {\n  childList: true,\n  subtree: true\n};\n\nvar ShadowMutationObserver =\n/*#__PURE__*/\nfunction () {\n  function ShadowMutationObserver() {\n    var _this = this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        context = _ref.context,\n        callback = _ref.callback,\n        config = _ref.config;\n\n    _classCallCheck(this, ShadowMutationObserver);\n\n    this.config = config;\n    this.disengage = this.disengage.bind(this);\n    this.clientObserver = new MutationObserver(callback);\n    this.hostObserver = new MutationObserver(function (mutations) {\n      return mutations.forEach(_this.handleHostMutation, _this);\n    });\n    this.observeContext(context);\n    this.observeShadowHosts(context);\n  }\n\n  _createClass(ShadowMutationObserver, [{\n    key: \"disengage\",\n    value: function disengage() {\n      this.clientObserver && this.clientObserver.disconnect();\n      this.clientObserver = null;\n      this.hostObserver && this.hostObserver.disconnect();\n      this.hostObserver = null;\n    }\n  }, {\n    key: \"observeShadowHosts\",\n    value: function observeShadowHosts(context) {\n      var _this2 = this;\n\n      var hosts = queryShadowHosts({\n        context: context\n      });\n      hosts.forEach(function (element) {\n        return _this2.observeContext(element.shadowRoot);\n      });\n    }\n  }, {\n    key: \"observeContext\",\n    value: function observeContext(context) {\n      this.clientObserver.observe(context, this.config);\n      this.hostObserver.observe(context, shadowObserverConfig);\n    }\n  }, {\n    key: \"handleHostMutation\",\n    value: function handleHostMutation(mutation) {\n      if (mutation.type !== 'childList') {\n        return;\n      }\n\n      var addedElements = nodeArray(mutation.addedNodes).filter(function (element) {\n        return element.nodeType === Node.ELEMENT_NODE;\n      });\n      addedElements.forEach(this.observeShadowHosts, this);\n    }\n  }]);\n\n  return ShadowMutationObserver;\n}();\n\nexport default function () {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      context = _ref2.context,\n      callback = _ref2.callback,\n      config = _ref2.config;\n\n  if (typeof callback !== 'function') {\n    throw new TypeError('observe/shadow-mutations requires options.callback to be a function');\n  }\n\n  if (typeof config !== 'object') {\n    throw new TypeError('observe/shadow-mutations requires options.config to be an object');\n  }\n\n  if (!window.MutationObserver) {\n    // not supporting IE10 via Mutation Events, because they're too expensive\n    // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events\n    return {\n      disengage: function disengage() {}\n    };\n  }\n\n  var element = contextToElement({\n    label: 'observe/shadow-mutations',\n    resolveDocument: true,\n    defaultToDocument: true,\n    context: context\n  });\n  var service = new ShadowMutationObserver({\n    context: element,\n    callback: callback,\n    config: config\n  });\n  return {\n    disengage: service.disengage\n  };\n}","map":null,"metadata":{},"sourceType":"module"}