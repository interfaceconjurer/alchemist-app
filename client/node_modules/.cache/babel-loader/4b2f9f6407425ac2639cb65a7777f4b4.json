{"ast":null,"code":"// sort a list of elements into another list of elements in DOM order\n\n/*\n  USAGE:\n    mergeDomOrder({\n      // DOM ordered array of elements to use as base of merge\n      list: [],\n      // unordered array of elements to merge into base list\n      elements: [],\n      // callback function to resolve an element\n      resolveElement: function(element) {\n        // return null to skip\n        // return element to replace insertion\n        // return [element1, element2, â€¦] to replace insertion with multiple elements\n        return element;\n      },\n    })\n*/\nimport findIndex from '../util/array-find-index';\nimport nodeArray from './node-array';\nimport sortDomOrder from './sort-dom-order';\n\nfunction getFirstSuccessorOffset(list, target) {\n  // find the first element that comes AFTER the target element\n  return findIndex(list, function (element) {\n    return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;\n  });\n}\n\nfunction findInsertionOffsets(list, elements, resolveElement) {\n  // instead of mutating the elements list directly, remember position and map\n  // to inject later, when we can do this more efficiently\n  var insertions = [];\n  elements.forEach(function (element) {\n    var replace = true;\n    var offset = list.indexOf(element);\n\n    if (offset === -1) {\n      // element is not in target list\n      offset = getFirstSuccessorOffset(list, element);\n      replace = false;\n    }\n\n    if (offset === -1) {\n      // there is no successor in the tabsequence,\n      // meaning the image must be the last element\n      offset = list.length;\n    } // allow the consumer to replace the injected element\n\n\n    var injections = nodeArray(resolveElement ? resolveElement(element) : element);\n\n    if (!injections.length) {\n      // we can't inject zero elements\n      return;\n    }\n\n    insertions.push({\n      offset: offset,\n      replace: replace,\n      elements: injections\n    });\n  });\n  return insertions;\n}\n\nfunction insertElementsAtOffsets(list, insertions) {\n  // remember the number of elements we have already injected\n  // so we account for the caused index offset\n  var inserted = 0; // make sure that we insert the elements in sequence,\n  // otherwise the offset compensation won't work\n\n  insertions.sort(function (a, b) {\n    return a.offset - b.offset;\n  });\n  insertions.forEach(function (insertion) {\n    // array.splice has an annoying function signature :(\n    var remove = insertion.replace ? 1 : 0;\n    var args = [insertion.offset + inserted, remove].concat(insertion.elements);\n    list.splice.apply(list, args);\n    inserted += insertion.elements.length - remove;\n  });\n}\n\nexport default function () {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      list = _ref.list,\n      elements = _ref.elements,\n      resolveElement = _ref.resolveElement;\n\n  // operate on a copy so we don't mutate the original array\n  var _list = list.slice(0); // make sure the elements we're injecting are provided in DOM order\n\n\n  var _elements = nodeArray(elements).slice(0);\n\n  sortDomOrder(_elements); // find the offsets within the target array (list) at which to inject\n  // each individual element (from elements)\n\n  var insertions = findInsertionOffsets(_list, _elements, resolveElement); // actually inject the elements into the target array at the identified positions\n\n  insertElementsAtOffsets(_list, insertions);\n  return _list;\n}","map":null,"metadata":{},"sourceType":"module"}